const InstantOverview = require("../src/exec.js")
  //require("../single/index.js");
const publish = InstantOverview.publish;
publish({
  article: {
    "url": "https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/r81qpe/",
    "title": "图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台",
    "desc": "根据定义，时间复杂度指输入数据大小为 NNN 时，算法运行所需花费的时间。需要注意：",
    "tags": "wechat, javascript",
    "content": "<sr-rd-content><blockquote>\n  <p>根据定义，时间复杂度指输入数据大小为 NNN 时，算法运行所需花费的时间。需要注意：</p>\n</blockquote>\n<h3 id=\"\">概念定义</h3>\n<p>根据定义，时间复杂度指输入数据大小为 N 时，算法运行所需花费的时间。需要注意：</p>\n<ul>\n<li>统计的是算法的「计算操作数量」，而不是「运行的绝对时间」。计算操作数量和运行绝对时间呈正相关关系，并不相等。算法运行时间受到「编程语言 、计算机处理器速度、运行环境」等多种因素影响。例如，同样的算法使用 Python 或 C++ 实现、使用 CPU 或 GPU 、使用本地 IDE 或力扣平台提交，运行时间都不同。</li>\n<li>体现的是计算操作随数据大小 N 变化时的变化情况。假设算法运行总共需要「 1 次操作」、「 100 次操作」，此两情况的时间复杂度都为常数级 O(1) ；需要「 N 次操作」、「 100N 次操作」的时间复杂度都为 O(N) 。</li>\n</ul>\n<hr />\n<h3 id=\"-1\">符号表示</h3>\n<p>根据输入数据的特点，时间复杂度具有「最差」、「平均」、「最佳」三种情况，分别使用 O , Θ , Ω 三种符号表示。以下借助一个查找算法的示例题目帮助理解。</p>\n<blockquote>\n  <p><strong>题目：</strong> 输入长度为 N 的整数数组 <code>nums</code> ，判断此数组中是否有数字 7 ，若有则返回 <code>true</code> ，否则返回 false 。</p>\n  <p><strong>解题算法：</strong> 线性查找，即遍历整个数组，遇到 7 则返回 <code>true</code> 。</p>\n  <p><strong>代码：</strong></p>\n  <ul>\n  <li>Python</li>\n  <li>Java</li>\n  <li>C++</li>\n  </ul>\n<pre><code>def find_seven(nums):\n    for num in nums:\n        if num == 7:\n            return True\n    return False\n</code></pre>\n<pre><code>boolean findSeven(int[] nums) {\n    for (int num : nums) {\n        if (num == 7)\n            return true;\n    }\n    return false;\n}\n</code></pre>\n<pre><code>bool findSeven(vector&lt;int&gt;&amp; nums) {\n    for (int num : nums) {\n        if (num == 7)\n            return true;\n    }\n    return false;\n}\n</code></pre>\n</blockquote>\n<ul>\n<li><strong>最佳情况 Ω(1) ：</strong> <code>nums = [7, a, b, c, ...]</code> ，即当数组首个数字为 7 时，无论 <code>nums</code> 有多少元素，线性查找的循环次数都为 1 次；</li>\n<li><strong>最差情况 O(N) ：</strong> <code>nums = [a, b, c, ...]</code> 且 <code>nums</code> 中所有数字都不为 7 ，此时线性查找会遍历整个数组，循环 N 次；</li>\n<li><strong>平均情况 Θ ：</strong> 需要考虑输入数据的分布情况，计算所有数据情况下的平均时间复杂度；例如本题目，需要考虑数组长度、数组元素的取值范围等；</li>\n</ul>\n<blockquote>\n  <p>大 O 是最常使用的时间复杂度评价渐进符号，下文示例与本 LeetBook 题目解析皆使用 O 。</p>\n</blockquote>\n<hr />\n<h3 id=\"-2\">常见种类</h3>\n<p>根据从小到大排列，常见的算法时间复杂度主要有：</p>\n<p>O(1)&lt;O(logN)&lt;O(N)&lt;O(NlogN)&lt;O(N2)&lt;O(2N)&lt;O(N!)</p>\n<p><img src=\"https://pic.leetcode-cn.com/1623519242-UTNefQ-Picture1.png\" alt=\"\" /></p>\n<hr />\n<h3 id=\"-3\">示例解析</h3>\n<p>对于以下所有示例，设输入数据大小为 N ，计算操作数量为 count 。图中每个「<strong>蓝色方块</strong>」代表一个单元计算操作。</p>\n<h4 id=\"httpsleetcodecncomleetbookreadillustrationofalgorithmr81qpee5b8b8e695b0efbc9ao1\"><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/r81qpe/#%E5%B8%B8%E6%95%B0-%EF%BC%9A\"></a>常数 O(1) ：</h4>\n<p>运行次数与 N 大小呈常数关系，即不随输入数据大小 N 的变化而变化。</p>\n<ul>\n<li>Python</li>\n<li>Java</li>\n<li>C++</li>\n</ul>\n<pre><code>def algorithm(N):\n    a = 1\n    b = 2\n    x = a * b + N\n    return 1\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int a = 1;\n    int b = 2;\n    int x = a * b + N;\n    return 1;\n}\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int a = 1;\n    int b = 2;\n    int x = a * b + N;\n    return 1;\n}\n</code></pre>\n<p>对于以下代码，无论 a 取多大，都与输入数据大小 N 无关，因此时间复杂度仍为 O(1) 。</p>\n<ul>\n<li>Python</li>\n<li>Java</li>\n<li>C++</li>\n</ul>\n<pre><code>def algorithm(N):\n    count = 0\n    a = 10000\n    for i in range(a):\n        count += 1\n    return count\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    int a = 10000;\n    for (int i = 0; i &lt; a; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    int a = 10000;\n    for (int i = 0; i &lt; a; i++) {\n        count++;\n    }\n    return count;\n}\n</code></pre>\n<p><img src=\"https://pic.leetcode-cn.com/1623779241-lViysV-Picture2.png\" alt=\"\" /></p>\n<h4 id=\"httpsleetcodecncomleetbookreadillustrationofalgorithmr81qpee7babfe680a7efbc9aon\"><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/r81qpe/#%E7%BA%BF%E6%80%A7-%EF%BC%9A\"></a>线性 O(N) ：</h4>\n<p>循环运行次数与 N 大小呈线性关系，时间复杂度为 O(N) 。</p>\n<ul>\n<li>Python</li>\n<li>Java</li>\n<li>C++</li>\n</ul>\n<pre><code>def algorithm(N):\n    count = 0\n    for i in range(N):\n        count += 1\n    return count\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    for (int i = 0; i &lt; N; i++)\n        count++;\n    return count;\n}\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    for (int i = 0; i &lt; N; i++)\n        count++;\n    return count;\n}\n</code></pre>\n<p>对于以下代码，虽然是两层循环，但第二层与 N 大小无关，因此整体仍与 N 呈线性关系。</p>\n<ul>\n<li>Python</li>\n<li>Java</li>\n<li>C++</li>\n</ul>\n<pre><code>def algorithm(N):\n    count = 0\n    a = 10000\n    for i in range(N):\n        for j in range(a):\n            count += 1\n    return count\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    int a = 10000;\n    for (int i = 0; i &lt; N; i++) {\n        for (int j = 0; j &lt; a; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    int a = 10000;\n    for (int i = 0; i &lt; N; i++) {\n        for (int j = 0; j &lt; a; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre>\n<p><img src=\"https://pic.leetcode-cn.com/1623519242-AhnqvJ-Picture3.png\" alt=\"\" /></p>\n<h4 id=\"httpsleetcodecncomleetbookreadillustrationofalgorithmr81qpee5b9b3e696b9efbc9aon2\"><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/r81qpe/#%E5%B9%B3%E6%96%B9-%EF%BC%9A\"></a>平方 O(N2) ：</h4>\n<p>两层循环相互独立，都与 N 呈线性关系，因此总体与 N 呈平方关系，时间复杂度为 O(N2) 。</p>\n<ul>\n<li>Python</li>\n<li>Java</li>\n<li>C++</li>\n</ul>\n<pre><code>def algorithm(N):\n    count = 0\n    for i in range(N):\n        for j in range(N):\n            count += 1\n    return count\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    for (int i = 0; i &lt; N; i++) {\n        for (int j = 0; j &lt; N; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    for (int i = 0; i &lt; N; i++) {\n        for (int j = 0; j &lt; N; j++) {\n            count++;\n        }\n    }\n    return count;\n}\n</code></pre>\n<p>以「冒泡排序」为例，其包含两层独立循环：</p>\n<ol>\n<li><p>第一层复杂度为 O(N) ；</p></li>\n<li><p>第二层平均循环次数为 2N​ ，复杂度为 O(N) ，推导过程如下：</p>\n<p>O(2N​)=O(21​)O(N)=O(1)O(N)=O(N)</p></li>\n</ol>\n<p>因此，冒泡排序的总体时间复杂度为 O(N2) ，代码如下所示。</p>\n<ul>\n<li>Python</li>\n<li>Java</li>\n<li>C++</li>\n</ul>\n<pre><code>def bubble_sort(nums):\n    N = len(nums)\n    for i in range(N - 1):\n        for j in range(N - 1 - i):\n            if nums[j] &gt; nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n</code></pre>\n<pre><code>int[] bubbleSort(int[] nums) {\n    int N = nums.length;\n    for (int i = 0; i &lt; N - 1; i++) {\n        for (int j = 0; j &lt; N - 1 - i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                int tmp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = tmp;\n            }\n        }\n    }\n    return nums;\n}\n</code></pre>\n<pre><code>vector&lt;int&gt; bubbleSort(vector&lt;int&gt;&amp; nums) {\n    int N = nums.size();\n    for (int i = 0; i &lt; N - 1; i++) {\n        for (int j = 0; j &lt; N - 1 - i; j++) {\n            if (nums[j] &gt; nums[j + 1]) {\n                swap(nums[j], nums[j + 1]);\n            }\n        }\n    }\n    return nums;\n}\n</code></pre>\n<p><img src=\"https://pic.leetcode-cn.com/1623519242-piiPrs-Picture4.png\" alt=\"\" /></p>\n<h4 id=\"httpsleetcodecncomleetbookreadillustrationofalgorithmr81qpee68c87e695b0efbc9ao2n\"><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/r81qpe/#%E6%8C%87%E6%95%B0-%EF%BC%9A\"></a>指数 O(2N) ：</h4>\n<p>生物学科中的 “细胞分裂” 即是指数级增长。初始状态为 1 个细胞，分裂一轮后为 2 个，分裂两轮后为 4 个，……，分裂 N 轮后有 2N 个细胞。</p>\n<p>算法中，指数阶常出现于递归，算法原理图与代码如下所示。</p>\n<ul>\n<li>Python</li>\n<li>Java</li>\n<li>C++</li>\n</ul>\n<pre><code>def algorithm(N):\n    if N &lt;= 0: return 1\n    count_1 = algorithm(N - 1)\n    count_2 = algorithm(N - 1)\n    return count_1 + count_2\n</code></pre>\n<pre><code>int algorithm(int N) {\n    if (N &lt;= 0) return 1;\n    int count_1 = algorithm(N - 1);\n    int count_2 = algorithm(N - 1);\n    return count_1 + count_2;\n}\n</code></pre>\n<pre><code>int algorithm(int N) {\n    if (N &lt;= 0) return 1;\n    int count_1 = algorithm(N - 1);\n    int count_2 = algorithm(N - 1);\n    return count_1 + count_2;\n}\n</code></pre>\n<p><img src=\"https://pic.leetcode-cn.com/1623519242-XLBkIT-Picture5.png\" alt=\"\" /></p>\n<h4 id=\"httpsleetcodecncomleetbookreadillustrationofalgorithmr81qpee998b6e4b998efbc9aon\"><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/r81qpe/#%E9%98%B6%E4%B9%98-%EF%BC%9A\"></a>阶乘 O(N!) ：</h4>\n<p>阶乘阶对应数学上常见的 “全排列” 。即给定 N 个互不重复的元素，求其所有可能的排列方案，则方案数量为：</p>\n<p>N×(N−1)×(N−2)×⋯×2×1=N!</p>\n<p>如下图与代码所示，阶乘常使用递归实现，算法原理：第一层分裂出 N 个，第二层分裂出 N−1 个，…… ，直至到第 N 层时终止并回溯。</p>\n<ul>\n<li>Python</li>\n<li>Java</li>\n<li>C++</li>\n</ul>\n<pre><code>def algorithm(N):\n    if N &lt;= 0: return 1\n    count = 0\n    for _ in range(N):\n        count += algorithm(N - 1)\n    return count\n</code></pre>\n<pre><code>int algorithm(int N) {\n    if (N &lt;= 0) return 1;\n    int count = 0;\n    for (int i = 0; i &lt; N; i++) {\n        count += algorithm(N - 1);\n    }\n    return count;\n}\n</code></pre>\n<pre><code>int algorithm(int N) {\n    if (N &lt;= 0) return 1;\n    int count = 0;\n    for (int i = 0; i &lt; N; i++) {\n        count += algorithm(N - 1);\n    }\n    return count;\n}\n</code></pre>\n<p><img src=\"https://pic.leetcode-cn.com/1623519242-AFSqrK-Picture6.png\" alt=\"\" /></p>\n<h4 id=\"httpsleetcodecncomleetbookreadillustrationofalgorithmr81qpee5afb9e695b0efbc9aologn\"><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/r81qpe/#%E5%AF%B9%E6%95%B0-%EF%BC%9A\"></a>对数 O(logN) ：</h4>\n<p>对数阶与指数阶相反，指数阶为 “每轮分裂出两倍的情况” ，而对数阶是 “每轮排除一半的情况” 。对数阶常出现于「二分法」、「分治」等算法中，体现着 “一分为二” 或 “一分为多” 的算法思想。</p>\n<p>设循环次数为 m ，则输入数据大小 N 与 2m 呈线性关系，两边同时取 log2​ 对数，则得到循环次数 m 与 log2​N 呈线性关系，即时间复杂度为 O(logN) 。</p>\n<ul>\n<li>Python</li>\n<li>Java</li>\n<li>C++</li>\n</ul>\n<pre><code>def algorithm(N):\n    count = 0\n    i = N\n    while i &gt; 1:\n        i = i / 2\n        count += 1\n    return count\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    float i = N;\n    while (i &gt; 1) {\n        i = i / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    float i = N;\n    while (i &gt; 1) {\n        i = i / 2;\n        count++;\n    }\n    return count;\n}\n</code></pre>\n<p>如以下代码所示，对于不同 a 的取值，循环次数 m 与 loga​N 呈线性关系 ，时间复杂度为 O(loga​N) 。而无论底数 a 取值，时间复杂度都可记作 O(logN) ，根据对数换底公式的推导如下：</p>\n<p>O(loga​N)=O(log2​a)O(log2​N)​=O(logN)</p>\n<ul>\n<li>Python</li>\n<li>Java</li>\n<li>C++</li>\n</ul>\n<pre><code>def algorithm(N):\n    count = 0\n    i = N\n    a = 3\n    while i &gt; 1:\n        i = i / a\n        count += 1\n    return count\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    float i = N;\n    int a = 3;\n    while (i &gt; 1) {\n        i = i / a;\n        count++;\n    }\n    return count;\n}\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    float i = N;\n    int a = 3;\n    while (i &gt; 1) {\n        i = i / a;\n        count++;\n    }\n    return count;\n}\n</code></pre>\n<blockquote>\n  <p>如下图所示，为二分查找的时间复杂度示意图，每次二分将搜索区间缩小一半。</p>\n</blockquote>\n<p><img src=\"https://pic.leetcode-cn.com/1623519242-WthaZa-Picture7.png\" alt=\"\" /></p>\n<h4 id=\"httpsleetcodecncomleetbookreadillustrationofalgorithmr81qpee7babfe680a7e5afb9e695b0efbc9aonlogn\"><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/r81qpe/#%E7%BA%BF%E6%80%A7%E5%AF%B9%E6%95%B0-%EF%BC%9A\"></a>线性对数 O(NlogN) ：</h4>\n<p>两层循环相互独立，第一层和第二层时间复杂度分别为 O(logN) 和 O(N) ，则总体时间复杂度为 O(NlogN) ；</p>\n<ul>\n<li>Python</li>\n<li>Java</li>\n<li>C++</li>\n</ul>\n<pre><code>def algorithm(N):\n    count = 0\n    i = N\n    while i &gt; 1:\n        i = i / 2\n        for j in range(N):\n            count += 1\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    float i = N;\n    while (i &gt; 1) {\n        i = i / 2;\n        for (int j = 0; j &lt; N; j++)\n            count++;\n    }\n    return count;\n}\n</code></pre>\n<pre><code>int algorithm(int N) {\n    int count = 0;\n    float i = N;\n    while (i &gt; 1) {\n        i = i / 2;\n        for (int j = 0; j &lt; N; j++)\n            count++;\n    }\n    return count;\n}\n</code></pre>\n<p>线性对数阶常出现于排序算法，例如「快速排序」、「归并排序」、「堆排序」等，其时间复杂度原理如下图所示。</p>\n<p><img src=\"https://pic.leetcode-cn.com/1623519242-rhCOIh-Picture8.png\" alt=\"\" /></p>\n<hr />\n<h3 id=\"-4\">示例题目</h3>\n<p>以下列举本 LeetBook 中各时间复杂度的对应示例题解，以帮助加深理解。</p>\n<table><thead><tr><th>时间复杂度</th><th>示例题解</th></tr></thead><tbody><tr><td><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math>O(1)</td><td><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5vyva2/\" target=\"_blank\">剑指 Offer 14- I. 剪绳子</a>、<a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/572x9r/\" target=\"_blank\">剑指 Offer 61. 扑克牌中的顺子</a></td></tr><tr><td><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>\u2061</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log N)</annotation></semantics></math>O(logN)</td><td><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/57p2pv/\" target=\"_blank\">剑指 Offer 16. 数值的整数次方</a>、<a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/58lgr7/\" target=\"_blank\">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></td></tr><tr><td><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math>O(N)</td><td><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/9p7s17/\" target=\"_blank\">剑指 Offer 24. 反转链表</a>、<a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/50fji7/\" target=\"_blank\">剑指 Offer 10- I. 斐波那契数列</a></td></tr><tr><td><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>log</mi><mo>\u2061</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N \\log N)</annotation></semantics></math>O(NlogN)</td><td><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/59ceyt/\" target=\"_blank\">剑指 Offer 45. 把数组排成最小的数</a>、<a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/o53yjd/\" target=\"_blank\">剑指 Offer 51. 数组中的逆序对</a></td></tr><tr><td><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math>O(N2)</td><td><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5vwbf6/\" target=\"_blank\">剑指 Offer 33. 二叉搜索树的后序遍历序列</a>、<a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5dz9di/\" target=\"_blank\">剑指 Offer 48. 最长不含重复字符的子字符串</a></td></tr><tr><td><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N!)</annotation></semantics></math>O(N!)</td><td><a href=\"https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/50hah3/\" target=\"_blank\">剑指 Offer 38. 字符串的排列</a></td></tr></tbody></table></sr-rd-content>"
  }
}).then(function (result) {
  console.log("测试20220118-4:", result);
});